name: deploy-aws-common-infra
description: Create AWS resources that are necessary for all `appTypes` in Autobahn
author: dploy

inputs:
  app-name:
    description: The application name
    required: true
  app-type:
    description: 'The type of app, only necessary for run images. Possible values: shiny, job, shiny-job, streamlit or library'
    default: library
  package-name:
    description: The name of the package in the packagemanager
    default: ${{ github.event.repository.name }}
  otap:
    # This input variable is deprecated and being overwritten
    description: The environment in which the app will run, e.g. O, T, A or P, only necessary for run images
    default: O
  account-id:
    description: The AWS account-id
    required: true
  region:
    description: The (custom) AWS region to deploy to
    default: eu-central-1
  reuse-alb:
    description: Reuse a common ALB for multiple deployments
    default: 'true'
  repository:
    description: A common image repository to write to, if not provided it will be app-name
    default: Auto
  use-efs:
    description: Does your application use an EFS share for in/output files?
    default: 'false'
  efs-file-system-name:
    description: The file share for in/output of data files
    required: true
  immutable-tags:
    description: Whether to use immutable tags for the ECR repository
    default: 'true'
  cdk-bootstrap:
    description: Whether to bootstrap the CDK environment
    default: 'true'

outputs:
  ecr-repo-name:
    description: The repository name
    value: ${{ steps.set-resources.outputs.repository }}
  efs-file-system-id:
    description: The EFS id
    value: ${{ steps.create-efs.outputs.efs-file-system-id }}
  ec2-alb-listener-rule-prio:
    description: The priority of the ALB listener rule
    value: ${{ steps.determine-alb-listener-prio.outputs.ec2-alb-listener-rule-prio }}

runs:
  using: "composite"
  steps:
    - name: Pre-flight check non-empty inputs
      shell: bash
      run: | # shell
        # Checking if required inputs are not empty
        declare -A inputs=(
          ["app-name"]="${{ inputs.app-name }}"
          ["app-type"]="${{ inputs.app-type }}"
          ["package-name"]="${{ inputs.package-name }}"
          ["otap"]="${{ inputs.otap }}"
          ["account-id"]="${{ inputs.account-id }}"
          ["region"]="${{ inputs.region }}"
          ["reuse-alb"]="${{ inputs.reuse-alb }}"
          ["repository"]="${{ inputs.repository }}"
          ["use-efs"]="${{ inputs.use-efs }}"
          ["efs-file-system-name"]="${{ inputs.efs-file-system-name }}"
          ["immutable-tags"]="${{ inputs.immutable-tags }}"
          ["cdk-bootstrap"]="${{ inputs.cdk-bootstrap }}"
        )

        # Check each input
        for input in "${!inputs[@]}"; do
          value="${inputs[${input}]}"
          if [ -z "${value}" ]; then
            echo "::error::'${input}' is empty"
            exit 1
          fi
        done

    - name: Pre-flight check boolean inputs
      shell: bash
      run: | # shell
        # Checking if boolean inputs are 'true' or 'false'
        declare -A inputs=(
          ["reuse-alb"]="${{ inputs.reuse-alb }}"
          ["use-efs"]="${{ inputs.use-efs }}"
          ["immutable-tags"]="${{ inputs.immutable-tags }}"
          ["cdk-bootstrap"]="${{ inputs.cdk-bootstrap }}"
        )

        # Iterate over each boolean input
        for input in "${!inputs[@]}"; do
          value="${inputs[${input}]}"
          if [[ "${value}" != "true" && "${value}" != "false" ]]; then
            echo "::error::'${input}' must be 'true' or 'false'"
            exit 1
          fi
        done
    
    - name: Pre-flight check list of values inputs
      shell: bash
      run: | # shell
        # Checking if inputs are in a list of valid values
        declare -A inputs=(
          ["app-type"]="${{ inputs.app-type }}"
          ["app-type_VALID_VALUES"]="dash, dash-task,\
                                     fastapi, fastapi-task,\
                                     frontend,\
                                     job, job-definition,\
                                     shiny, shiny-task,\
                                     streamlit, streamlit-task,\
                                     task-definition"
          ["otap"]="${{ inputs.otap }}"
          ["otap_VALID_VALUES"]="O, T, A, P"
          ["region"]="${{ inputs.region }}"
          ["region_VALID_VALUES"]="eu-central-1"
        )

        # Check if the input is in the list of valid values
        for input in "${!inputs[@]}"; do
          # Skip the valid values entries
          if [[ "${input}" == *_VALID_VALUES ]]; then
            continue
          fi

          value="${inputs[${input}]}"
          valid_values="${inputs[${input}_VALID_VALUES]}"
          if [[ ! "$valid_values" =~ "${value}" ]]; then
            echo "::error::'${input}' must be one of the following values: ${valid_values}, you specified ${value}"
            exit 1
          fi
        done

    - name: Pre-flight check git repository
      shell: bash
      run: | # shell
        if ! git branch 2> /dev/null; then 
          echo "::error::Not in a git repository. Exiting.."
          exit 1
        fi
        
    - name: Prepare
      id: prepare
      shell: bash
      run: |
        echo "mutability=$([[ "${{ inputs.immutable-tags }}" == "true" ]] && echo "IMMUTABLE" || echo "MUTABLE")" >> ${GITHUB_OUTPUT}

    - name: Setup node/npm
      uses: actions/setup-node@v4
      with:
        always-auth: true
        node-version: 20.x
        registry-url: https://npm.pkg.github.com
        scope: "@alliander"

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-region: ${{ inputs.region }}
        role-to-assume: arn:aws:iam::${{ inputs.account-id }}:role/gh-actions-${{ github.event.repository.name }}
        role-session-name: GitHubActions

    - name: Install CDK globally and install projects dependencies
      shell: bash
      run: |
        npm i -g aws-cdk
        cd ${GITHUB_ACTION_PATH}

        #emulate npm ci https://github.com/aws/aws-pdk/issues/755
        rm -rf node_modules; npm install --no-save
        
    - name: CDK bootstrap
      id: bootstrap
      if: ${{ inputs.cdk-bootstrap == 'true' }}
      shell: bash
      run: |
        cd ${GITHUB_ACTION_PATH}
        echo "Bootstrapping environment"
        cdk bootstrap --app "" aws://${{ inputs.account-id }}/${{ inputs.region }}

    - name: Set resources
      id: set-resources
      shell: bash
      run: |
        if [[ "${{ inputs.repository }}" == "Auto" ]]
        then
          echo "repository=${{ inputs.app-name }}" >> ${GITHUB_OUTPUT}
        else
          echo "repository=${{ inputs.repository }}/${{ inputs.app-name }}" >> ${GITHUB_OUTPUT}
        fi
        echo "securityGroupName=${{ inputs.efs-file-system-name }}SecurityGroup" >> ${GITHUB_OUTPUT}

    - name: Create ECR if not exists
      shell: bash
      run: |
        repositoryArn=$(aws ecr describe-repositories \
          --output text \
          --repository-names "${{ steps.set-resources.outputs.repository }}" \
          --query "repositories[0].repositoryArn") || echo "Repository not found"        

        if [[ "${repositoryArn}" != "" ]]
        then
          echo "Repository found with arn ${repositoryArn}"
          if aws ecr list-tags-for-resource \
            --resource-arn "$repositoryArn" \
            --query 'tags' 2>&1 | grep -q '"Value": "Cli"' ||
             aws ssm list-tags-for-resource \
            --resource-type "Parameter" \
            --resource-id "/application/v1/${{ inputs.app-name }}/ecrRepository" 2>&1 | grep -q '"Value": "Cli"'
          then
            echo "ECR repository created by Cli found, deleting it" >> ${GITHUB_STEP_SUMMARY}
            aws ecr delete-repository --repository-name ${{ steps.set-resources.outputs.repository }} --force
            aws ssm delete-parameter --name /application/v1/${{ inputs.app-name }}/ecrRepository
          fi  
        fi

        # If the SSM parameter hasn't been deployed with CDK, the ECR repository isn't part of a stack either
        if aws ssm list-tags-for-resource \
          --resource-type "Parameter" \
          --resource-id "/application/v1/${{ inputs.app-name }}/ecrRepository" 2>&1 | grep -q '"Value": "Cli"'
        then
          echo "SSM parameter for ECR repository created by Cli found, deleting ECR repository and SSM parameter" >> ${GITHUB_STEP_SUMMARY}
          aws ssm delete-parameter --name /application/v1/${{ inputs.app-name }}/ecrRepository
        fi

    - name: Fetch VPC settings
      id: fetch-vpc-settings
      if: ${{ inputs.use-efs == 'true' }}
      shell: bash
      run: |
        echo "vpcId=$(aws ssm get-parameter --output text --name "/platform/v1/vpc/id" --query "Parameter.Value")" >> ${GITHUB_OUTPUT}
        echo "subnetAz1a=$(aws ssm get-parameter --output text --name "/platform/v1/vpc/az1a/subnetids/Private" --query "Parameter.Value")" >> ${GITHUB_OUTPUT}
        echo "subnetAz1b=$(aws ssm get-parameter --output text --name "/platform/v1/vpc/az1b/subnetids/Private" --query "Parameter.Value")" >> ${GITHUB_OUTPUT}
        echo "subnetAz1c=$(aws ssm get-parameter --output text --name "/platform/v1/vpc/az1c/subnetids/Private" --query "Parameter.Value")" >> ${GITHUB_OUTPUT}

    - name: Create EFS
      id: create-efs
      if: ${{ inputs.use-efs == 'true' }}
      shell: bash
      run: |
        # Fetch the fileSystemId, create otherwise
        if [[ "$(aws efs describe-file-systems \
            --output text \
            --query 'FileSystems[?Name==`${{ inputs.efs-file-system-name }}`].FileSystemId' \
            --region ${{ inputs.region }})" == "" ]]
        then
          aws efs create-file-system \
            --performance-mode generalPurpose \
            --throughput-mode bursting \
            --encrypted \
            --region ${{ inputs.region }} \
            --tags Key=Name,Value=${{ inputs.efs-file-system-name }} Key=CreatedBy,Value=Autobahn Key=DeployedBy,Value=Cli
        fi

        echo "efs-file-system-id=$(aws efs describe-file-systems \
            --output text \
            --query 'FileSystems[?Name==`${{ inputs.efs-file-system-name }}`].FileSystemId' \
            --region ${{ inputs.region }})" >> ${GITHUB_OUTPUT}

    - name: Create EFS security group
      id: create-security-group
      if: ${{ inputs.use-efs == 'true' }}
      shell: bash
      run: |
        # Fetch the EFS security group, create otherwise
        if [[ "$(aws ec2 describe-security-groups \
            --output text \
            --region ${{ inputs.region }} \
            --filters Name=group-name,Values=${{ steps.set-resources.outputs.securityGroupName }} \
            --query SecurityGroups[].GroupId)" == "" ]]
        then
          aws ec2 create-security-group \
            --output text \
            --region ${{ inputs.region }} \
            --description "SecurityGroup for the ${{ inputs.efs-file-system-name }} EFS filesystem share" \
            --group-name ${{ steps.set-resources.outputs.securityGroupName }} \
            --vpc-id ${{ steps.fetch-vpc-settings.outputs.vpcId }} \
            --tag-specifications 'ResourceType=security-group,Tags=[{Key=CreatedBy,Value=Autobahn},{Key=DeployedBy,Value=Cli}]'
        fi

        echo "efsSecurityGroupId=$(aws ec2 describe-security-groups \
            --output text \
            --region ${{ inputs.region }} \
            --filters Name=group-name,Values=${{ steps.set-resources.outputs.securityGroupName }} \
            --query SecurityGroups[].GroupId)" >> ${GITHUB_OUTPUT}

    - name: Store EFS file-system-id and security group in SSM
      if: ${{ inputs.use-efs == 'true' }}
      shell: bash
      run: |
        aws ssm put-parameter \
          --output text \
          --name /application/v1/${{ inputs.app-name }}/efsFileSystemId \
          --value ${{ steps.create-efs.outputs.efs-file-system-id }} \
          --type "String" \
          --overwrite

        aws ssm add-tags-to-resource \
          --resource-type "Parameter" \
          --resource-id "/application/v1/${{ inputs.app-name }}/efsFileSystemId" \
          --tags '[{"Key":"CreatedBy","Value":"Autobahn"},{"Key":"DeployedBy", "Value":"Cli"}]'

        aws ssm put-parameter \
          --output text \
          --name /application/v1/${{ inputs.app-name }}/efsSecurityGroupId \
          --value ${{ steps.create-security-group.outputs.efsSecurityGroupId }} \
          --type "String" \
          --overwrite

        aws ssm add-tags-to-resource \
          --resource-type "Parameter" \
          --resource-id "/application/v1/${{ inputs.app-name }}/efsSecurityGroupId" \
          --tags '[{"Key":"CreatedBy","Value":"Autobahn"},{"Key":"DeployedBy", "Value":"Cli"}]'

    - name: Set EFS security group rules
      if: ${{ inputs.use-efs == 'true' }}
      shell: bash
      run: |
        # Check if inbound port 22 (SSH) rule is configured, create otherwise
        if [[ "$(aws ec2 describe-security-groups --output text --filters Name=group-name,Values=${{ steps.set-resources.outputs.securityGroupName }} --query SecurityGroups[].IpPermissions[].FromPort | grep -c 22)" == 0 ]]
        then
          aws ec2 authorize-security-group-ingress \
              --group-id ${{ steps.create-security-group.outputs.efsSecurityGroupId }} \
              --ip-permissions IpProtocol=tcp,FromPort=22,ToPort=22,IpRanges='[{CidrIp=10.0.0.0/8,Description="SSH"}]'
        fi

        # Check if inbound port 2049 (NFS) rule is configured, create otherwise
        if [[ "$(aws ec2 describe-security-groups --output text --filters Name=group-name,Values=${{ steps.set-resources.outputs.securityGroupName }} --query SecurityGroups[].IpPermissions[].FromPort | grep -c 2049)" == 0 ]]
        then
          aws ec2 authorize-security-group-ingress \
              --group-id ${{ steps.create-security-group.outputs.efsSecurityGroupId }} \
              --ip-permissions IpProtocol=tcp,FromPort=2049,ToPort=2049,IpRanges='[{CidrIp=10.0.0.0/8,Description="NFS"}]'
        fi

    - name: Create EFS mount targets
      if: ${{ inputs.use-efs == 'true' }}
      shell: bash
      run: |
        # Fetch the mount targets, create otherwise
        if [[ "$(aws efs describe-mount-targets --output text --file-system-id ${{ steps.create-efs.outputs.efs-file-system-id }})" == "" ]]
        then
          aws efs create-mount-target \
            --file-system-id ${{ steps.create-efs.outputs.efs-file-system-id }} \
            --security-groups ${{ steps.create-security-group.outputs.efsSecurityGroupId }} \
            --subnet-id ${{ steps.fetch-vpc-settings.outputs.subnetAz1a }}

          aws efs create-mount-target \
            --file-system-id ${{ steps.create-efs.outputs.efs-file-system-id }} \
            --security-groups ${{ steps.create-security-group.outputs.efsSecurityGroupId }} \
            --subnet-id ${{ steps.fetch-vpc-settings.outputs.subnetAz1b }}

          aws efs create-mount-target \
            --file-system-id ${{ steps.create-efs.outputs.efs-file-system-id }} \
            --security-groups ${{ steps.create-security-group.outputs.efsSecurityGroupId }} \
            --subnet-id ${{ steps.fetch-vpc-settings.outputs.subnetAz1c }}
        fi

    - name: Create AppStream access point
      id: create-appstream-access-point
      if: ${{ inputs.use-efs == 'true' }}
      shell: bash
      run: |
        # Fetch the existing access point (/data/static) for the AppStream user (UID:GID 1002:1004), create otherwise
        if [[ "$(aws efs describe-access-points \
            --output text \
            --file-system-id ${{ steps.create-efs.outputs.efs-file-system-id }} \
            --query 'AccessPoints[?RootDirectory.Path==`/data/static`].AccessPointId')" == "" ]]
        then
          aws efs create-access-point \
            --region ${{ inputs.region }} \
            --file-system-id ${{ steps.create-efs.outputs.efs-file-system-id }} \
            --tags Key="Type,Value=AppStream" Key=CreatedBy,Value=Autobahn Key=DeployedBy,Value=Cli \
            --root-directory Path="/data/static,CreationInfo={OwnerUid=1002,OwnerGid=1004,Permissions=777}"
        fi

        echo "appStreamAccessPointId=$(aws efs describe-access-points \
            --output text \
            --file-system-id ${{ steps.create-efs.outputs.efs-file-system-id }} \
            --query 'AccessPoints[?RootDirectory.Path==`/data/static`].AccessPointId')" \
            >> ${GITHUB_OUTPUT}

    - name: Check application access point permissions
      id: check-efs-access-point
      if: ${{ inputs.use-efs == 'true' }}
      shell: bash
      run: |
        # Check access point permissions for AppStream user, recreate otherwise
        if [[ "$(aws efs describe-access-points \
            --output text \
            --access-point-id ${{ steps.create-appstream-access-point.outputs.appStreamAccessPointId }} \
            --query 'AccessPoints[].RootDirectory[].CreationInfo[].OwnerUid')" != "1002" || "$(aws efs describe-access-points \
            --output text \
            --access-point-id ${{ steps.create-appstream-access-point.outputs.appStreamAccessPointId }} \
            --query 'AccessPoints[].RootDirectory[].CreationInfo[].OwnerGid')" != "1004" ]]
        then
          aws efs delete-access-point --access-point-id ${{ steps.create-appstream-access-point.outputs.appStreamAccessPointId }}

          aws efs create-access-point \
            --region ${{ inputs.region }} \
            --file-system-id ${{ steps.create-efs.outputs.efs-file-system-id }} \
            --tags Key="Type,Value=AppStream" Key=CreatedBy,Value=Autobahn Key=DeployedBy,Value=Cli \
            --root-directory Path="/data/static,CreationInfo={OwnerUid=1002,OwnerGid=1004,Permissions=777}"
        fi

    - name: Check for old access-point path and throw error
      shell: bash
      run: |
        if [[ "${{ inputs.app-name}}" != "${{ inputs.package-name }}" ]]
        then
          if [[ "$(aws efs describe-access-points \
              --output text \
              --file-system-id ${{ steps.create-efs.outputs.efs-file-system-id }} \
              --query 'AccessPoints[?RootDirectory.Path==`/data/static/${{ inputs.otap }}/${{ inputs.package-name }}`].AccessPointId')" != "" ]]
          then
            echo "::error::An old access-point has been found, please contact team DPLOY for migration!"
            exit 1
          fi
        fi

    - name: Check for common ALB
      shell: bash
      id: fetch-alb-and-listener
      if: ${{ (inputs.reuse-alb && inputs.app-type != 'job') }}
      run: |
        echo "ssmALB=$(aws ssm get-parameter \
            --output text \
            --name "/application/v1/common/ApplicationLoadBalancerARN" \
            --query "Parameter.Value")" >> ${GITHUB_OUTPUT}

        echo "ssmALBListener=$(aws ssm get-parameter \
            --output text \
            --name "/application/v1/common/ApplicationLoadBalancerListenerARN" \
            --query "Parameter.Value")" >> ${GITHUB_OUTPUT}

    - name: Create a common ALB and listener (port 443) if desired
      shell: bash
      if: ${{ (inputs.reuse-alb && inputs.app-type != 'job') }}
      run: |
        if [[ "${{ steps.fetch-alb-and-listener.outputs.ssmALB }}" != "" && "${{ steps.fetch-alb-and-listener.outputs.ssmALBListener }}" != "" ]]
        then
          echo "::notice::Existing ALB ${{ steps.fetch-alb-and-listener.outputs.ssmALBListener }} found, using it for Continuous Deployment"
          echo "ec2ALBListenerARN=${{ steps.fetch-alb-and-listener.outputs.ssmALBListener }}" >> ${GITHUB_OUTPUT}
        else
          cd ${GITHUB_ACTION_PATH}
          cdk deploy \
            $(if [ "${{ inputs.cdkRollbackOnFailure }}" == "false" ]; then echo "--no-rollback"; fi) \
            -O CfnOutput.json

          cat CfnOutput.json
        fi

    - name: Fetch and update last listener rule prio
      shell: bash
      id: determine-alb-listener-prio
      if: ${{ (inputs.reuse-alb && inputs.app-type != 'job' && inputs.app-type != 'job-definition') }}
      run: |
        # Fetch existing ALB ListenerRule Prio if exists
        PARAM_VALUE=$(aws ssm get-parameter \
                            --output text \
                            --name /application/v1/${{ inputs.app-name }}/ApplicationLoadBalancerListenerRulePrio \
                            --query Parameter.Value 2> /dev/null) || echo "Priority parameter doesn't exist"

        # If not found, bump last registered prio and store value in SSM
        if [[ $PARAM_VALUE == '' ]]
        then
          PARAM_VALUE=$(aws ssm get-parameter \
                                --output text \
                                --name /application/v1/common/ApplicationLoadBalancerListenerRuleLastPrio \
                                --query Parameter.Value 2> /dev/null) || echo "Priority parameter doesn't exist"

          PARAM_VALUE=$((PARAM_VALUE + 1))

          aws ssm put-parameter \
                  --output text \
                  --name /application/v1/common/ApplicationLoadBalancerListenerRuleLastPrio \
                  --value $PARAM_VALUE \
                  --type "String" \
                  --overwrite

        fi

        echo "ec2-alb-listener-rule-prio=$PARAM_VALUE" >> ${GITHUB_OUTPUT}

    - name: Upload diagram artifact
      id: upload-artifact
      uses: Alliander/publish-workflow-cdk-graph-diagram@main
      with:
        artifact-name: Common-Infra-Diagram
        root-dir: ${{ github.action_path }}
